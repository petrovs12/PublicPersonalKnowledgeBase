{"pageProps":{"note":{"id":"7YVDJqBL721tr9IQJeKBW","title":"Greedy Algorithms","desc":"","updated":1641902106013,"created":1641864734961,"custom":{},"fname":"science.CS.algos.Greedy Algorithms","type":"note","vault":{"fsPath":"vault"},"contentHash":"4b9049e68f816858f1f150260584d245","links":[{"type":"wiki","from":{"fname":"science.CS.algos.Greedy Algorithms","id":"7YVDJqBL721tr9IQJeKBW","vaultName":"vault"},"value":"science.math.theory.Algebra.Matroids","position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":41,"offset":40},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"science.math.theory.Algebra.Matroids"}},{"from":{"fname":"math.theory.Information Theory","id":"rKkRfVi4X4JfJCVHHiGfY","vaultName":"vault"},"type":"backlink","position":{"start":{"line":19,"column":1,"offset":184},"end":{"line":19,"column":39,"offset":222},"indent":[]},"value":"science.CS.algos.Greedy Algorithms"},{"from":{"fname":"science.stats.Decision Trees","id":"Xtfmm6UoEH3509PDjc007","vaultName":"vault"},"type":"backlink","position":{"start":{"line":2,"column":56,"offset":56},"end":{"line":2,"column":94,"offset":94},"indent":[]},"value":"science.CS.algos.Greedy Algorithms"}],"anchors":{"huffman-coding":{"type":"header","text":"Huffman Coding:","value":"huffman-coding","line":10,"column":0,"depth":1},"dijkstra":{"type":"header","text":"Dijkstra:","value":"dijkstra","line":30,"column":0,"depth":2},"":{"type":"header","text":"","value":"","line":34,"column":0,"depth":2},"minimum-spanning-tree":{"type":"header","text":"Minimum Spanning Tree:","value":"minimum-spanning-tree","line":41,"column":0,"depth":2},"kruskal--do-that-need-prio-queue-and-union-find-to-keep-track-of-partial-forests":{"type":"header","text":"kruskal- do that, need prio queue and union find to keep track of partial forests","value":"kruskal--do-that-need-prio-queue-and-union-find-to-keep-track-of-partial-forests","line":45,"column":0,"depth":2},"prim-algorithm":{"type":"header","text":"Prim Algorithm","value":"prim-algorithm","line":48,"column":0,"depth":2},"horn-clauses":{"type":"header","text":"Horn clauses","value":"horn-clauses","line":55,"column":0,"depth":2},"now-2-sat-limits-the-problem-of-sat-to-only-those-boolean-formula-which-are-expressed-as-a-cnf-with-every-clause-having-only-2-termsalso-called-2-cnf":{"type":"header","text":"Now, 2-SAT limits the problem of SAT to only those Boolean formula which are expressed as a CNF with every clause having only 2 terms(also called 2-CNF).","value":"now-2-sat-limits-the-problem-of-sat-to-only-those-boolean-formula-which-are-expressed-as-a-cnf-with-every-clause-having-only-2-termsalso-called-2-cnf","line":96,"column":0,"depth":2},"or-with-negatives":{"type":"header","text":"OR with negatives:","value":"or-with-negatives","line":125,"column":0,"depth":2}},"children":[],"parent":"R3N3tS0RNCjMvqnqSnGZI","data":{}},"body":"<h1 id=\"greedy-algorithms\">Greedy Algorithms<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#greedy-algorithms\"></a></h1>\n<p><a href=\"/PublicPersonalKnowledgeBase/notes/cM8t2nF5lMGDVZpoOe79x\">Matroids</a></p>\n<h1 id=\"huffman-coding\">Huffman Coding:<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#huffman-coding\"></a></h1>\n<p>Minimizes Entropy:</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>E</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mi>y</mi><mi>m</mi><mi>b</mi><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mi>y</mi><mi>m</mi><mi>b</mi><mi>o</mi><mi>l</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>p</mi><mo>∗</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">min E(p(symb)*len(enc(symbol))) = E(-log_2 p*p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">min</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">sy</span><span class=\"mord mathnormal\">mb</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">sy</span><span class=\"mord mathnormal\">mb</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">)))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span></span>\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mi>y</mi><mi>m</mi><mi>b</mi><mi>o</mi><mi>l</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">len(symbol)= depth</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">sy</span><span class=\"mord mathnormal\">mb</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">pt</span><span class=\"mord mathnormal\">h</span></span></span></span></span></p>\n<p>can solve by greedy:\nbuild up tree bottom-up\nevery time join symbols w/ minimum prob/freq (and make another symbol for the join).\nrecover tree in the end\nuse priority queue to pop smallest frequency every time.</p>\n<p>huffman coding also minimizes entropy.</p>\n<hr>\n<p>greedy algo</p>\n<hr>\n<h2 id=\"dijkstra\">Dijkstra:<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#dijkstra\"></a></h2>\n<h2 id=\"\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#\"></a></h2>\n<p>negative edges:\ncombine op on edges\nrepeat |V|-1 times\nif wanna detect negative CYCLEs repeat once more and obs is fixed point changes.\ndijkstra wants prio queue</p>\n<h2 id=\"minimum-spanning-tree\">Minimum Spanning Tree:<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#minimum-spanning-tree\"></a></h2>\n<p>invariant: add minimal edge that doesn't add a cycle</p>\n<h2 id=\"kruskal--do-that-need-prio-queue-and-union-find-to-keep-track-of-partial-forests\">kruskal- do that, need prio queue and union find to keep track of partial forests<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#kruskal--do-that-need-prio-queue-and-union-find-to-keep-track-of-partial-forests\"></a></h2>\n<h2 id=\"prim-algorithm\">Prim Algorithm<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#prim-algorithm\"></a></h2>\n<p>keep track of tree only; then use priority queue (similar to dijkstra then, almost same.</p>\n<p>Vazirani algos:</p>\n<h2 id=\"horn-clauses\">Horn clauses<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#horn-clauses\"></a></h2>\n<p> Implications, whose left-hand side is an AND of anynumber of positive literals and whose\nright-hand side is a single positive literal. These express statements of the form “if the\nconditions on the left hold, then the one on the right must also be true.” For instance,\n(z ∧ w) => u\nmight mean “if the colonel was asleep at 8 pm and the murder took place at 8 pm then\nthe colonel is innocent.” A degenerate type of implication is the singleton “⇒ x,” meaning\nsimply that x is true: “the murder definitely occurred in the kitchen.”\n2. Pure negative clauses, consisting of an OR of any number of negative literals, as in\n(!u ∨ !v ∨ !y)\n(“they can’t all be innocent”).\nGiven a set of clauses of these two types, the goal is to determine whether there is a consis-\ntent explanation: an assignment of true/false values to the variables that satisfies all the\nclauses. This is also called a satisfying assignment.</p>\n<p>So SAT is in general np-hard\nbut if instead set of horn clauses, greedy efficient\n<a href=\"https://tryalgo.org/en/satisfiability/2016/12/04/horn-sat/\">https://tryalgo.org/en/satisfiability/2016/12/04/horn-sat/</a>\nlinear time algo for horn clauses (horn-sat, instead of SAT).\nAnother mention here:\n<a href=\"https://people.eecs.berkeley.edu/~sseshia/219c/lectures/SATSolving.pdf\">https://people.eecs.berkeley.edu/~sseshia/219c/lectures/SATSolving.pdf</a></p>\n<p>2-sat</p>\n<p>Special Cases of 3-SAT that are\npolynomial-time solvable\n• 2-SAT\n– T. Larrabee observed that many clauses in\nATPG tend to be 2-CNF\n• Horn-SAT\n– A clause is a Horn clause if at most one literal\nis positive\n– If all clauses are Horn, then problem is HornSAT\n– E.g. Application:- Checking that one finitestate system refines (implements) anoth</p>\n<p><a href=\"https://www.geeksforgeeks.org/2-satisfiability-2-sat-problem/\">https://www.geeksforgeeks.org/2-satisfiability-2-sat-problem/</a>\nso horn-sat and 2-sat\nTo understand this better, first let us see what is Conjunctive Normal Form (CNF) or also known as Product of Sums (POS).\nCNF : CNF is a conjunction (AND) of clauses, where every clause is a disjunction (OR).</p>\n<h2 id=\"now-2-sat-limits-the-problem-of-sat-to-only-those-boolean-formula-which-are-expressed-as-a-cnf-with-every-clause-having-only-2-termsalso-called-2-cnf\">Now, 2-SAT limits the problem of SAT to only those Boolean formula which are expressed as a CNF with every clause having only 2 terms(also called 2-CNF).<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#now-2-sat-limits-the-problem-of-sat-to-only-those-boolean-formula-which-are-expressed-as-a-cnf-with-every-clause-having-only-2-termsalso-called-2-cnf\"></a></h2>\n<p>so 2-sat is if we can make cnf w/ 2 clauses everywhere...</p>\n<hr>\n<p>The two kinds of clauses pull us in different directions. The implications tell us to set\nsome of the variables to true, while the negative clauses encourage us to make them false.\nOur strategy for solving a Horn formula is this: We start with all variables false. We then\nproceed to set some of them to true, one by one, but very reluctantly, and only if we absolutely\nhave to because an implication would otherwise be violated. Once we are done with this phase\nand all implications are satisfied, only then do we turn to the negative clauses and make sure\nthey are all satisfied</p>\n<hr>\n<p>this scheme is linear-time and 'greedy' in the negative sense (we want many literals to be false cuase of the negative clauses.</p>\n<hr>\n<p>horn clause thing:\n2 types of clauses:\nPositive Implicative:\nrhs is single positive\nlhs is any number of positive :\n(a and b)=>c\n=>c\n.. etc\n(a and b and c)=>d\npure negative:</p>\n<h2 id=\"or-with-negatives\">OR with negatives:<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#or-with-negatives\"></a></h2>\n<p>'greedy' :start with all false, then only make true is some implication is broken.\nwhen all implications are ok, check all pure negatives.'</p>\n<hr>\n<p>5.4. Set cover greedy approximation:</p>\n<hr>\n<p>Pick the set w/ largest number of uncovered elements has ln(n) approximation ratio.</p>\n<hr>\n<p>Shortest paths in dags are easy</p>\n<hr>\n<p>dag-> can linearize</p>\n<p>'</p>\n<hr>\n<strong>Backlinks</strong>\n<ul>\n<li><a href=\"/PublicPersonalKnowledgeBase/notes/rKkRfVi4X4JfJCVHHiGfY\">Information Theory</a></li>\n<li><a href=\"/PublicPersonalKnowledgeBase/notes/Xtfmm6UoEH3509PDjc007\">Decision Trees</a></li>\n</ul>","noteIndex":{"id":"wn8PE1RhG0znK1alrGFYv","title":"Root","desc":"","updated":1647507231129,"created":1631901573363,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"db285659ccac8b133c384de1ef51de66","links":[],"anchors":{"welcome-to-stefans-notes":{"type":"header","text":"Welcome to Stefan's Notes!","value":"welcome-to-stefans-notes","line":7,"column":0,"depth":1}},"children":["mxzxxu8z4e6krz99ht96y9d","W1EOZ27Tqx6RbiA2aW3DI","DyoLE2kwm9rRfRZhBGxPW","idhfogizmtcmvaamtalp3o3","4w8wBCSRvYUnGIZeozW03","vB321AipYCs6ldVC0APs9","h6WVdl1UTWVXeWuMJSZ1f","bth6m0exy9q9loxib1mc4al","4abAmH56ausbldEJbZokx","JyOFJ5NTPSVWMfiDy951X","0OO7fjCpcaGZg5qDRZr8z","138666663","pohXgII67dAxnoufG7yAP","6hs48bnjnaoxahk07exj74u","42r6290iqzLPmg9BY7fIp","3hoLerNJHjNkDziIKlFF2","T6meT3UNw0nRorEbzoPSl","hIOTXIIBj3vmhG1xc91lA","tnFlQuOAGPkbU2fZI7Cb1","Jb3w3f4x8kixLhrjUW6S1","LV6q5jlD2xtCF6yYFEqFC","ENDcCZFjAW9h66eDoFg7I","b5IeREnsTbeggC7rmWV0p","2hmbhdzcdljtdwln762gcrv","z9la6u9t3xueldj2omf2gc6","9akeo93l6b026jmu4t6e7pw","sc24o4jglr9jg29qr5v0e44","0mt5ao8tbbz3z5mdwe0aer8","r7rvb6nal69nfb6ogqdadnm","xujx5iuxskj10o0ajpi109n","lyl1rzqz6zwcswpwh0kafrm","skpw697vlqdq3t3uqxpq5e3","a4tts3oc3oms7wuralrbzdc","13a1ufqh6o8yi9evw1u5kv5"],"parent":null,"data":{},"body":"# Welcome to Stefan's Notes!\n\n        \n\nLast updated: 2021.12.30\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableUserTags":true,"enableHashTags":true,"dendronVersion":"0.95.0","enableEditorDecorations":true,"enableFullHierarchyNoteTitle":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","assetsPrefix":"/PublicPersonalKnowledgeBase","siteUrl":"https://petrovs12.github.io","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"theme":"light","templateVersion":"0.97.0","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}