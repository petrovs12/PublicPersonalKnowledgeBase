{"pageProps":{"note":{"id":"7Jd2ym5CmQjaalbIJ4nYj","title":"Scoreboard","desc":"","updated":1643220747617,"created":1643216594659,"custom":{},"fname":"engineering.system_design.Scoreboard","type":"note","vault":{"fsPath":"vault"},"contentHash":"65e1dcc9bee513a1f58c404675c2c5f1","links":[],"anchors":{},"children":[],"parent":"gImPQvOVGCsqgPnkpuVfC","data":{}},"body":"<h1 id=\"scoreboard\">Scoreboard<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#scoreboard\"></a></h1>\n<p>We can:</p>\n<ol>\n<li>For each user, keep bucket_id, and score. </li>\n<li>For each bucket, keep bucket_id, user_id, lower_bound,upper_bound, score, next and previous bucket pointers. </li>\n<li>The ranking table is split into buckets.</li>\n<li>When the user score is updates, we:</li>\n</ol>\n<ul>\n<li>\n<p>update the user score</p>\n</li>\n<li>\n<p>check if we're still in the same bucket, else delete user from bucket, go up or down bucket pointers, and add user to new bucket. Alternatively, we can first consult a the bucket table above, and we can figure out the appropriate new bucket .</p>\n</li>\n<li>\n<p>evern 100 ms, sort each bucket in parallel, using insertion sort. If we detect some buckets have too many inversions,\ncan switch them to merge sort (too many games in a given bracket).</p>\n</li>\n<li>\n<p>if sorting time for any bucket becomes too large (>e.g. 50ms), then split the bucket into two,\nmove upper part of the user range to new bucket.</p>\n</li>\n<li>\n<p>We retrieve 10 above and bellow you in the same bucket. For edge cases where  you're the top/bottom 9 person in bucket- have 2 parallel 'bucket' sequences: e.g. percentiles 0,2,...,98,100, and percentiles 0,1,3,5,...,99,100, search for user in both sequences. At least  1 of them will contain the -10-user_rank;10 +user_rank interval completely (or can use the bucket pointers, mentioned before)</p>\n</li>\n<li>\n<p>For sorting the friend list: </p>\n</li>\n</ul>\n<ol>\n<li>\n<p>If friend list is undirected, maintain these equivalence relations sort and retrieve them\nThen we use similar sorting mechanisms for each friend list.\nFriend lists are equivalence relationships, every time a user plays a game, update their score, use a procedure as above.</p>\n</li>\n<li>\n<p>If friend list is directed\nMaintain list to show to each user.</p>\n</li>\n</ol>\n<p>For players with not many incoming friends (ppl who follow them):\nEvery such player is a pub-sub topic, to which ppl who follow them subscribe.\nThen when game happens, the user publishes to the topic, and the topic publishes to all the users who follow it,\nupdating their 'friend' scoreboard w/ insertion sort.</p>\n<p>For players with many incoming friends (ppl who follow them) :\nCelebrity problem\nDon't update follower scoreboard directly, but for each user, maintain a special list of celebrities they follow, and at\nrequest- time, if there was update, insertion-sort them into the existing 'friend' scoreboards. </p>","noteIndex":{"id":"wn8PE1RhG0znK1alrGFYv","title":"Root","desc":"","updated":1647507231129,"created":1631901573363,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"db285659ccac8b133c384de1ef51de66","links":[],"anchors":{"welcome-to-stefans-notes":{"type":"header","text":"Welcome to Stefan's Notes!","value":"welcome-to-stefans-notes","line":7,"column":0,"depth":1}},"children":["mxzxxu8z4e6krz99ht96y9d","W1EOZ27Tqx6RbiA2aW3DI","DyoLE2kwm9rRfRZhBGxPW","idhfogizmtcmvaamtalp3o3","4w8wBCSRvYUnGIZeozW03","vB321AipYCs6ldVC0APs9","h6WVdl1UTWVXeWuMJSZ1f","bth6m0exy9q9loxib1mc4al","4abAmH56ausbldEJbZokx","JyOFJ5NTPSVWMfiDy951X","0OO7fjCpcaGZg5qDRZr8z","138666663","pohXgII67dAxnoufG7yAP","6hs48bnjnaoxahk07exj74u","42r6290iqzLPmg9BY7fIp","3hoLerNJHjNkDziIKlFF2","T6meT3UNw0nRorEbzoPSl","hIOTXIIBj3vmhG1xc91lA","tnFlQuOAGPkbU2fZI7Cb1","Jb3w3f4x8kixLhrjUW6S1","LV6q5jlD2xtCF6yYFEqFC","ENDcCZFjAW9h66eDoFg7I","b5IeREnsTbeggC7rmWV0p","2hmbhdzcdljtdwln762gcrv","z9la6u9t3xueldj2omf2gc6","9akeo93l6b026jmu4t6e7pw","sc24o4jglr9jg29qr5v0e44","0mt5ao8tbbz3z5mdwe0aer8","r7rvb6nal69nfb6ogqdadnm","xujx5iuxskj10o0ajpi109n","lyl1rzqz6zwcswpwh0kafrm","skpw697vlqdq3t3uqxpq5e3","a4tts3oc3oms7wuralrbzdc","13a1ufqh6o8yi9evw1u5kv5"],"parent":null,"data":{},"body":"# Welcome to Stefan's Notes!\n\n        \n\nLast updated: 2021.12.30\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableUserTags":true,"enableHashTags":true,"dendronVersion":"0.95.0","enableEditorDecorations":true,"enableFullHierarchyNoteTitle":false,"templateHierarchy":"template"},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","assetsPrefix":"/PublicPersonalKnowledgeBase","siteUrl":"https://petrovs12.github.io","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"theme":"light","templateVersion":"0.97.0","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}