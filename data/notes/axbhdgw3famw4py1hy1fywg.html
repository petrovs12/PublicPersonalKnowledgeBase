<h1 id="lmql">LMQL<a aria-hidden="true" class="anchor-heading icon-link" href="#lmql"></a></h1>
<h1 id="lmql-1">LMQL<a aria-hidden="true" class="anchor-heading icon-link" href="#lmql-1"></a></h1>
<p>syntaxt</p>
<p>'' where ...</p>
<h1 id="clauses">Clauses<a aria-hidden="true" class="anchor-heading icon-link" href="#clauses"></a></h1>
<h2 id="where-clause">where clause<a aria-hidden="true" class="anchor-heading icon-link" href="#where-clause"></a></h2>
<p>specify some constraints on the output</p>
<h2 id="the-main-program-caluse">the main program caluse<a aria-hidden="true" class="anchor-heading icon-link" href="#the-main-program-caluse"></a></h2>
<p>Basically we can have some holes inn a text and some python expressions inside, where we're predicting the masked words.</p>
<p>Then as the model is generating stuff according to the strategy, there is a mechanism to enforce the constraints.</p>
<p>How does this work? with partial evaluation.
First note how LLM's generate their output.
Before I thought they generate it trough only a deterministic greedy procedure, but actually they can use
other graph search algorithms, where the log-probablity of the output is the weight function in the inference graph. So they can do beam search, greedy search, etc.</p>
<p>As they go they know what variable is being 'generated' at the moment. This variable has some current value and on the basis of this one can say if the variable is violating some constraints. If yes, the search procedure can backtrack. If not, it can continue, while also knowing if the variable can have something added to it, or not.
I think these are generated as 'follow' and 'fin' nodes in the graph for a particular variable.</p>
<p>Examples:
If a var is constrained to be in a list (e.g. 'positive' or 'negtive') that can work in an obvious way..</p>
<p>other things...</p>
<p>It saves 26-60% ofthe cost, but sort of a 'normal amound', as it can cut off unsatisfiable branches.</p>
<p>quite flexeble with the constraints, have to learn more about the syntax...
There was this syntax </p>
<pre><code>sample(temperature=1.2)
"A few things not to forget when going to the sea (not travelling):\n "
"-[THING]" where stops_at(thing,"\n")
"-[THING]" where stops_at(thing,"\n")
"-[THING]" where stops_at(thing,"\n")
"-[THING]" where stops_at(thing,"\n")
</code></pre>
<p>where 'thing' is not the same everywhere.</p>
<p>Quite good at enforxing consistency, eg.g by a clause like:</p>
<pre><code>"A few things not to forget when going to the sea (not travelling):\n "
</code></pre>
<h3 id="its-also-included-in-langchain">It's also included in LangChain<a aria-hidden="true" class="anchor-heading icon-link" href="#its-also-included-in-langchain"></a></h3>
<p>As we've geneRated the partial outpud</p>
<h2 id="decoder-clause">decoder clause<a aria-hidden="true" class="anchor-heading icon-link" href="#decoder-clause"></a></h2>
<p>Specity the decoding algorithm to use,
can be sample, argmax/or other stuff, like beam or best_k</p>
<p>Beam, argmax.
,
sample, beam_sample, beam_var,...</p>
<h2 id="from-clause">from clause<a aria-hidden="true" class="anchor-heading icon-link" href="#from-clause"></a></h2>
<p>specify the model to use</p>
<h1 id="related-work">Related work<a aria-hidden="true" class="anchor-heading icon-link" href="#related-work"></a></h1>
<h3 id="language-model-programming">Language Model Programming<a aria-hidden="true" class="anchor-heading icon-link" href="#language-model-programming"></a></h3>
<p>All sorts of chain-of-thought and similar things can be considered as part of language model programming...</p>
<p>Chain of thought prompting, tree of thought, and others are all part of this and instantiations of it.</p>